<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 卢文的博客</title>
    <link>http://luwen.tech/post/</link>
    <description>Recent content in Posts on 卢文的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 20 Oct 2019 11:24:39 +0800</lastBuildDate>
    
	<atom:link href="http://luwen.tech/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>解决golang依赖包问题</title>
      <link>http://luwen.tech/post/%E8%A7%A3%E5%86%B3golang%E4%BE%9D%E8%B5%96%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 20 Oct 2019 11:24:39 +0800</pubDate>
      
      <guid>http://luwen.tech/post/%E8%A7%A3%E5%86%B3golang%E4%BE%9D%E8%B5%96%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>问题描述 当我们使用 go get、go install、go mod 等命令时，会自动下载相应的包或依赖包。但由于众所周知的原因，类似于 golang.org/x/&amp;hellip; 的包会出现下载失败的情况。如下所示： 123 $ go get -u golang.org/x/sysgo get golang.org/x/sys: unrecognized import path &amp;ldquo;golang.org/x/sys&amp;rdquo; (https fetch: Get https://golang.org/x/sys?go-get=1: dial tcp 216.239.37.1:443: i/o timeout) 解决方式 那我们该如何解决问题呢？毕竟还要制造 bug 的嘛~ 手动下载 我们常见的 golang.org/x/&amp;hellip; 包，一般</description>
    </item>
    
    <item>
      <title>Kubernetes弹性伸缩</title>
      <link>http://luwen.tech/post/kubernetes%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</link>
      <pubDate>Mon, 14 Oct 2019 14:02:43 +0800</pubDate>
      
      <guid>http://luwen.tech/post/kubernetes%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</guid>
      <description>自动弹性伸缩(AutoScaling)，是Kubernetes的一大功能和亮点。在OpenStack IaaS云计算中也有类似的服务，即Senlin。即基于资源使用情况自动弹性缩容和扩容工作负载。Kubernetes的自动弹性伸缩有两个维度： Cluster Autoscaler：处理K8s集群N</description>
    </item>
    
    <item>
      <title>Rds优化</title>
      <link>http://luwen.tech/post/rds%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 12 Oct 2019 10:08:04 +0800</pubDate>
      
      <guid>http://luwen.tech/post/rds%E4%BC%98%E5%8C%96/</guid>
      <description>事务长事务的防范手段。参数loose_max_statement_time可以控制大查询的最大执行时间，超过这个时间后，会把查询kill掉。参数loose_rds_strict_trx_idle_timeout可以控制空闲事务的最长存活时间，当一个事务空闲状态超过这个值时候，会主</description>
    </item>
    
    <item>
      <title>Kubernetes常用命令</title>
      <link>http://luwen.tech/post/kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 29 Sep 2019 13:49:25 +0800</pubDate>
      
      <guid>http://luwen.tech/post/kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>1.查看资源占用： kubectl describe node &amp;ldquo;cn-beijing.172.16.89.154&amp;rdquo; | sed &amp;lsquo;1,/Non-terminated Pods/d&amp;rsquo; 2.进入pod Kubectl exec -it pod -n namespace /bin/bash 3.查看pod资源消耗 Kubectl top pod -n prod 指定 Node 节点调度 有三种方式指定 Pod 只运行在指定的 Node 节点上 nodeSelector：只调度到匹配指定 label 的 Node 上 nodeAffinity：功能更丰富的 Node 选择器，比如支持集合操作 podAffinit</description>
    </item>
    
    <item>
      <title>Kubernetes探针最佳实践</title>
      <link>http://luwen.tech/post/kubernetes%E6%8E%A2%E9%92%88%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 20 Aug 2019 08:57:19 +0800</pubDate>
      
      <guid>http://luwen.tech/post/kubernetes%E6%8E%A2%E9%92%88%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>1. 存活和就绪的结果处理程序需要是互相独立的程序 如前所述，对于在Kubernetes上下文中部署的每个产品，应该实现2个分别处理HTTP请求“存活”和“就绪”的处理程序。这些探测器的处理程序需要独立实现自己的功能。 这适用于作业处理应用程序。对于Kubernetes，了解应用程序是否</description>
    </item>
    
    <item>
      <title>Kubernets资源限制</title>
      <link>http://luwen.tech/post/kubernetes%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</link>
      <pubDate>Thu, 15 Aug 2019 21:52:19 +0800</pubDate>
      
      <guid>http://luwen.tech/post/kubernetes%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</guid>
      <description>###普通应用资源限制 resources: limits: cpu: 100m memory: 1024Mi requests: cpu: 50m memory: 512Mi java jdk 8部分版本和更新版本的应用资源限制： env: - name: JAVA_OPTS value: &amp;quot;-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap&amp;quot; resources: limits: cpu: 100m memory: 1024Mi requests: cpu: 50m memory: 512Mi</description>
    </item>
    
    <item>
      <title>阿里云Kubernetes服务日志收集方案</title>
      <link>http://luwen.tech/post/%E9%98%BF%E9%87%8C%E4%BA%91k8s%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%96%B9%E6%A1%88/</link>
      <pubDate>Fri, 09 Aug 2019 16:16:24 +0800</pubDate>
      
      <guid>http://luwen.tech/post/%E9%98%BF%E9%87%8C%E4%BA%91k8s%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%96%B9%E6%A1%88/</guid>
      <description>Kubernetes集群中的日志收集 通用做法： 方案 优点 缺点 每个app的镜像中都集成日志收集组件 部署方便，kubernetes的yaml文件无须特别配置，可以为每个app自定义日志收集配置 强耦合，不方便应用和日志收集组件升级和维护且会导致镜像过大 单独创建一个日志收集组件跟app的容</description>
    </item>
    
  </channel>
</rss>