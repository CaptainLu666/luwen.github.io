<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on 卢文的博客</title>
    <link>http://luwen.tech/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on 卢文的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 18 Mar 2021 10:09:57 +0800</lastBuildDate><atom:link href="http://luwen.tech/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>悲观锁和乐观锁</title>
      <link>http://luwen.tech/post/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</link>
      <pubDate>Thu, 18 Mar 2021 10:09:57 +0800</pubDate>
      
      <guid>http://luwen.tech/post/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</guid>
      <description>乐观锁和悲观锁概念 一、并发控制 当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。 没有做</description>
    </item>
    
    <item>
      <title>Sql学习</title>
      <link>http://luwen.tech/post/sql%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 06 Nov 2020 16:54:58 +0800</pubDate>
      
      <guid>http://luwen.tech/post/sql%E5%AD%A6%E4%B9%A0/</guid>
      <description>廖雪峰的sql</description>
    </item>
    
    <item>
      <title>Mysql按日期分表</title>
      <link>http://luwen.tech/post/mysql%E6%8C%89%E6%97%A5%E6%9C%9F%E5%88%86%E8%A1%A8/</link>
      <pubDate>Wed, 12 Aug 2020 09:42:44 +0800</pubDate>
      
      <guid>http://luwen.tech/post/mysql%E6%8C%89%E6%97%A5%E6%9C%9F%E5%88%86%E8%A1%A8/</guid>
      <description>###线上数据库历史订单记录表比较大，800多W条记录，频繁查询容易占用系统资源，按日期分表过程如下： 原表order记录数8501257 select count(1) from `order`; +----------+ | count(1) | +----------+ | 8501257 | +----------+ 创建临时新表并复制表结构： create table order_new like `order`; 重命名原表、改新表改名 rename table `order` to order_20200814; rename table order_new to `order`; 按业务需求导入数据 INSERT INTO `order`() SELECT * FROM order_20200814 WHERE CREATE_DATE &amp;gt; &amp;#39;2020-07-14</description>
    </item>
    
    <item>
      <title>Redis慢分析</title>
      <link>http://luwen.tech/post/redis%E6%85%A2%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 14 Nov 2019 18:11:41 +0800</pubDate>
      
      <guid>http://luwen.tech/post/redis%E6%85%A2%E5%88%86%E6%9E%90/</guid>
      <description>Redis 是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。但是 Redis 也会发生延迟时，这是就需要我们对其产生原因有深刻的了解，以便于快速排查问题，解决 Redis的延迟问题 一条命令执行过程 在本文场景下，延迟 (latency) 是指从客户端发送命令到客户端接收到命令返回值</description>
    </item>
    
    <item>
      <title>Rds优化</title>
      <link>http://luwen.tech/post/rds%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 12 Oct 2019 10:08:04 +0800</pubDate>
      
      <guid>http://luwen.tech/post/rds%E4%BC%98%E5%8C%96/</guid>
      <description>事务长事务的防范手段。参数loose_max_statement_time可以控制大查询的最大执行时间，超过这个时间后，会把查询kill掉。参数loose_rds_strict_trx_idle_timeout可以控制空闲事务的最长存活时间，当一个事务空闲状态超过这个值时候，会主</description>
    </item>
    
  </channel>
</rss>
